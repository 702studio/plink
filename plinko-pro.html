<!doctype html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Plinko Pro — Tek HTML</title>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wdth,wght@75..100,400..900&family=Plus+Jakarta+Sans:opsz,wght@8..40,400..800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" />
    <style>
      :root{
        /* Fonts */
        --font-display: "Teko", system-ui, sans-serif;
        --font-ui: "Plus Jakarta Sans", system-ui, sans-serif;
        --font-mono: "JetBrains Mono", ui-monospace, monospace;
        /* Type scale */
        --t-16:16px; --t-19:19px; --t-23:23px; --t-28:28px; --t-34:34px; --t-41:41px; --t-49:49px; --t-59:59px; --t-71:71px; --t-86:86px;
        /* Colors */
        --bg:#0B1020; --txt:#ECECEC; --c1:#00E5FF; --c2:#FF2ED1; --c3:#C8FF00;
        /* Legacy tokens */
        --line:#1f2430; --win:#34d399; --loss:#f87171;
      }
      *{box-sizing:border-box}
      html,body{margin:0;height:100%;background:var(--bg);color:var(--txt);font-family:var(--font-ui);}
      .app{height:100%;display:grid;grid-template-rows:auto 1fr auto}
      .top{position:sticky;top:0;z-index:5;background:rgba(6,16,24,.6);backdrop-filter:blur(8px);border-bottom:1px solid var(--line);padding:10px}
      .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
      .stack{display:flex;flex-direction:column;gap:6px}
      .meta{display:flex;gap:8px;flex-wrap:wrap}
      .title{font-family:var(--font-display);font-size:var(--t-34);letter-spacing:0.02em;font-variation-settings:"wght" 850}
      .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(0,229,255,.35);border-radius:999px;padding:8px 12px;background:rgba(0,229,255,.12)}
      .controls{display:flex;gap:10px;flex-wrap:wrap}
      label{display:flex;align-items:center;gap:8px;font-size:var(--t-16);color:#C9D0E5}
      input,select{background:#0d1724;color:var(--txt);border:1px solid #2a2e39;border-radius:10px;height:40px;padding:8px 12px;font-size:var(--t-16);}
      input[type=number].num{font-family:var(--font-mono);font-variant-numeric:tabular-nums;font-feature-settings:"zero" 1;}
      select{font-family:var(--font-ui)}
      button{cursor:pointer;font-weight:800;text-transform:uppercase;letter-spacing:.02em}
      .btn{display:inline-block;padding:10px 16px;border-radius:10px;border:none;font-size:var(--t-23)}
      .btn-compact{padding:4px 10px;font-size:var(--t-16);border-radius:8px}
      /* Narrow numeric widths */
      .w-3ch{width:3ch}
      .w-4ch{width:4ch}
      .w-6ch{width:6ch}
      .btn-primary{background:linear-gradient(90deg, var(--c2), var(--c1));color:#061018}
      .btn-secondary{background:#0d1724;color:var(--txt);border:1px solid #2a2e39}
      button:active{transform:translateY(1px)}
      .main{padding:10px;min-height:0;display:grid;grid-template-columns:1fr;gap:10px}
      .board{border:1px solid var(--line);border-radius:12px;overflow:hidden;background:linear-gradient(180deg, rgba(9,13,24,0.9), rgba(2,6,23,0.9));position:relative}
      canvas{display:block;width:100%;height:100%;touch-action:manipulation}
      
      .footer{border-top:1px solid var(--line);background:#0f1626;padding:8px 10px;display:flex;align-items:center;justify-content:space-between;gap:10px}
      .note{font-size:var(--t-16);opacity:.7;color:#C9D0E5}
      .toast{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.4);border:1px solid #274060;padding:12px 16px;border-radius:12px;font-weight:800;letter-spacing:.5px;backdrop-filter:blur(6px);display:none}
      .toast.show{display:block;animation:pop .7s ease}
      @keyframes pop{0%{transform:translate(-50%,-50%) scale(.8);opacity:0}50%{opacity:1}100%{transform:translate(-50%,-50%) scale(1)}}
      @media (max-width: 520px){ .controls{gap:8px} .title{font-size:14px} }

      /* Motion helpers */
      .hit{ animation: hit 120ms ease-out forwards; }
      @keyframes hit{ 0%{ transform:scale(1); font-variation-settings:"wght" 750; } 60%{ transform:scale(1.04); font-variation-settings:"wght" 900; letter-spacing:0.04em;} 100%{ transform:scale(1.0); font-variation-settings:"wght" 750; letter-spacing:0.02em;} }
      .bounce{ animation: bounce 90ms ease-out; }
      @keyframes bounce{ 0%{ letter-spacing:-0.01em; transform:translateY(-2px); } 60%{ letter-spacing:0.03em; transform:translateY(0); } 100%{ letter-spacing:0; } }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="top">
        <div class="row" style="justify-content:space-between">
          <div class="stack">
            <div class="title">Plinko Pro</div>
            <div class="meta">
              <div class="pill">Bakiye: <span id="bal" style="font-family:var(--font-mono);font-variant-numeric:tabular-nums; font-feature-settings:'zero' 1;">100.00</span></div>
              <div class="pill">Son Kazanç: <span id="last" style="font-family:var(--font-mono);font-variant-numeric:tabular-nums; font-feature-settings:'zero' 1;">-</span></div>
            </div>
          </div>
          <div class="controls">
             <label>Bahis <input id="bet" class="num w-6ch" type="number" value="10" min="1" step="1"></label>
            <label>Risk
              <select id="risk">
                <option value="low">Low</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High</option>
              </select>
            </label>
             <label>Satır <input id="rows" class="num w-4ch" type="number" value="12" min="8" max="16" step="1"></label>
             <label>Top <input id="balls" class="num w-4ch" type="number" value="5" min="1" max="50" step="1"></label>
             <button id="drop" class="btn btn-primary btn-compact">DROP!</button>
             <button id="auto" class="btn btn-secondary btn-compact">AUTO: Kapalı</button>
          </div>
        </div>
      </div>

      <div class="main">
        <div class="board">
          
          <canvas id="c"></canvas>
          <div id="toast" class="toast">+0.00</div>
        </div>
      </div>

      
    </div>

    <script>
      // --- Elements & State ---
      const cvs = document.getElementById('c');
      const ctx = cvs.getContext('2d');
      const balEl = document.getElementById('bal');
      const lastEl = document.getElementById('last');
      const toast = document.getElementById('toast');
      
      const elBet = document.getElementById('bet');
      const elRisk = document.getElementById('risk');
      const elRows = document.getElementById('rows');
      const elBalls = document.getElementById('balls');
      const btnDrop = document.getElementById('drop');
      const btnAuto = document.getElementById('auto');

      let W=0, H=0, dpr=1;
      let balance = 100;
      let rows = 12;
      let cols = rows + 1;
      let risk = 'medium';
      let bet = 10; // BET_PER_BALL=10 (design.md)
      let auto = false;
      let pins = []; // {x,y,r}
      let balls = []; // {x,y,vx,vy,r,trail:[],hue}
      let slots = []; // {x,w}
      let groundY = 0;
      let multipliers = [];
      let confetti = [];
      

      // --- Utils ---
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const rand=(a,b)=>Math.random()*(b-a)+a;
      const lerp=(a,b,t)=>a+(b-a)*t;
      const format=(n)=>n.toFixed(2);

      function gaussian(x, mean, sigma){
        const coeff = 1 / (sigma * Math.sqrt(2*Math.PI));
        const exponent = -((x-mean)**2) / (2*sigma**2);
        return coeff * Math.exp(exponent);
      }
      function buildMultipliers(rows, risk){
        // Edge-shaped: center low, edges high. Normalize to target RTP.
        const slotCount = rows + 1; const centerIndex = (slotCount-1)/2;
        const sigmaBase = Math.max(1.6, rows/4);
        const sigma = risk==='low'? sigmaBase*1.15 : risk==='medium'? sigmaBase : sigmaBase*0.75;
        // Base gains: invert gaussian so edges are higher
        const maxG = gaussian(centerIndex, centerIndex, sigma);
        const base=[];
        for(let i=0;i<slotCount;i++){
          const g = gaussian(i, centerIndex, sigma) / maxG; // 1 at center -> 0 at edges
          const inverted = 1 - g; // 0 center, 1 edges
          base.push(inverted);
        }
        // Map to multiplier range per risk
        const minMult = risk==='low'? 0.4 : risk==='medium'? 0.3 : 0.2; // floor
        const maxMult = risk==='low'? 8.0 : risk==='medium'? 18.0 : 35.0; // edges
        let arr = base.map(v => minMult + v*(maxMult - minMult));
        // Smooth slight center dip to avoid too-flat center
        if(slotCount>=5){
          const mid = Math.floor(centerIndex);
          arr[mid] = Math.max(minMult, arr[mid]*0.85);
        }
        // Normalize RTP to target per risk
        const targetRTP = risk==='low'? 0.945 : risk==='medium'? 0.92 : 0.90;
        // Approximate binomial probabilities for rows (p=0.5 per step)
        const probs = new Array(slotCount).fill(0);
        // Use Pascal triangle weights
        let totalWeight = 0;
        const weights = [];
        for(let k=0;k<slotCount;k++){
          // C(rows, k) where k rights among rows
          const w = comb(rows, k);
          weights.push(w); totalWeight += w;
        }
        for(let k=0;k<slotCount;k++) probs[k] = weights[k]/totalWeight;
        // Compute current RTP
        const currentRTP = arr.reduce((s,m,i)=> s + m*probs[i], 0) / 1; // bet=1 basis
        const scale = targetRTP / currentRTP;
        arr = arr.map(m => Number((m*scale).toFixed(2)));
        return arr;
      }

      function comb(n, k){
        if(k<0||k>n) return 0;
        k = Math.min(k, n-k);
        let num=1, den=1;
        for(let i=1;i<=k;i++){ num *= (n - (k - i)); den *= i; }
        return num/den;
      }

      // --- Layout ---
      function resize(){
        dpr = Math.min(2, window.devicePixelRatio||1);
        const board = cvs.parentElement.getBoundingClientRect();
        const targetH = Math.max(420, Math.min(window.innerHeight - 180, 760));
        cvs.style.height = targetH + 'px';
        cvs.width = Math.floor(board.width * dpr);
        cvs.height = Math.floor(targetH * dpr);
        cvs.style.width = Math.floor(cvs.width/dpr) + 'px';
        W = cvs.width; H = cvs.height;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        rebuildBoard();
      }

      function rebuildBoard(){
        rows = clamp(Number(elRows.value)||rows, 8, 16);
        cols = rows + 1;
        risk = elRisk.value;
        pins.length = 0; slots.length = 0; balls.length = 0; confetti.length=0;
        multipliers = buildMultipliers(rows, risk);

        const padX = 24, padYTop = 40, padYBottom = 140;
        const usableW = W/dpr - padX*2;
        const usableH = H/dpr - padYTop - padYBottom;
         // Design: equal horizontal and vertical spacing with hex pattern
         const colGap = usableW / (cols - 1);
         const rowGap = Math.sqrt(3)/2 * colGap;
         // Recompute usableH by rows to keep grid within board
         const gridH = rowGap * (rows-1);
         const yOffset = padYTop + Math.max(0, (usableH - gridH) / 2);
         const pinR = 5; // larger pins relative to ball
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            let x = padX + c*colGap + (r%2? colGap/2 : 0);
            if(x<padX || x>(W/dpr - padX)) continue;
             let y = yOffset + r*rowGap;
            pins.push({x,y,r:pinR});
          }
        }
         groundY = (H/dpr) - 60;
        const slotCount = cols;
         // Align slots with last row spacing
         const slotW = colGap;
        for(let i=0;i<slotCount;i++){
          slots.push({ x: padX + i*slotW, w: slotW });
        }
        // HUD removed; multipliers rendered near ground on canvas
      }

      // --- Physics ---
       function spawnBall(n=1){
        bet = clamp(Number(elBet.value)||bet, 1, 1e6);
        const count = clamp(Number(elBalls.value)||1, 1, 200);
        const total = n===1? count : n;
        // Cost upfront (design: pro multi-ball deducts pre-shot)
        const totalCost = bet * total;
        if(balance < totalCost){ showToast('Bakiye yetersiz', ''); return; }
        balance = Number((balance - totalCost).toFixed(2));
        balEl.textContent = format(balance);
        for(let i=0;i<total;i++){
          const hue = Math.floor(rand(180, 320));
          balls.push({ x: rand(40, (W/dpr)-40), y: -10, vx: rand(-1,1), vy: 0, r: 7, trail:[], hue });
        }
        
       }

      function step(dt){
        const g = 980; // px/s^2
        const air = 0.995;
        const e = 0.75; // restitution
        const left = 0, right = (W/dpr), top = 0, bottom = groundY;
        for(let b of balls){
          // gravity
          b.vy += g * dt;
          b.vx *= air; b.vy *= air;

          // integrate
          b.x += b.vx * dt; b.y += b.vy * dt;

          // walls
          if(b.x - b.r < left){ b.x = left + b.r; b.vx = -b.vx * e; }
          if(b.x + b.r > right){ b.x = right - b.r; b.vx = -b.vx * e; }
          if(b.y - b.r < top){ b.y = top + b.r; b.vy = -b.vy * e; }

          // pin collisions (naive)
          for(let p of pins){
            const dx = b.x - p.x, dy = b.y - p.y;
            const dist2 = dx*dx + dy*dy; const R = b.r + p.r;
            if(dist2 < R*R){
              const dist = Math.sqrt(dist2) || 0.0001;
              const nx = dx/dist, ny = dy/dist; // normal
              // push out
              const overlap = R - dist;
              b.x += nx * overlap; b.y += ny * overlap;
              // reflect velocity
              const vn = b.vx*nx + b.vy*ny;
              const tx = -ny, ty = nx; // tangent
              const vt = b.vx*tx + b.vy*ty;
              const rvn = -vn * e;
              b.vx = rvn*nx + vt*tx + (Math.random()-0.5)*0.2;
              b.vy = rvn*ny + vt*ty + (Math.random()-0.5)*0.2;
            }
          }

          // ground/slots
          if(b.y + b.r >= bottom){
            // find slot
            const sIdx = Math.max(0, Math.min(slots.length-1, Math.floor((b.x - slots[0].x) / slots[0].w)));
            const mult = multipliers[sIdx] || 1;
            const win = bet * mult;
            balance = Number((balance + win).toFixed(2));
            balEl.textContent = format(balance);
            lastEl.textContent = '+'+format(win)+' (×'+mult+')';
            showToast('+'+format(win)+' (×'+mult+')', mult>=3? 'big':'');
            if(mult>=3) spawnConfetti(b.x, bottom-10, mult);
            
            // remove ball
            b.remove = true;
          }

          // trail
          b.trail.push({x:b.x, y:b.y, a:1});
          if(b.trail.length>10) b.trail.shift();
        }
        balls = balls.filter(b=>!b.remove && b.y < (H/dpr)+40);

        // auto mode
        if(auto && Math.random()<0.15) spawnBall(1);

        // update confetti
        for(let p of confetti){ p.vy += 800*dt; p.vx *= 0.995; p.vy *= 0.995; p.x += p.vx*dt; p.y += p.vy*dt; p.rot += p.vr*dt; p.life -= dt; }
        confetti = confetti.filter(p=>p.life>0 && p.y < (H/dpr)+50);
      }

      function spawnConfetti(x,y,intensity){
        const n = Math.min(80, Math.floor(20*intensity));
        for(let i=0;i<n;i++){
          confetti.push({ x, y, vx: rand(-200,200), vy: rand(-300,-100), rot: rand(0,6.28), vr: rand(-6,6), life: rand(0.8,1.4), hue: Math.floor(rand(0,360)) });
        }
      }

      function showToast(text, kind){
        toast.textContent = text; toast.classList.add('show');
        toast.style.borderColor = kind==='big'? '#10b981' : '#274060';
        setTimeout(()=> toast.classList.remove('show'), 900);
      }

      

      // --- Micro motion hooks ---
      function animateHit(){
        document.querySelector('.title')?.classList.add('hit');
        setTimeout(()=> document.querySelector('.title')?.classList.remove('hit'), 220);
      }

      // --- Render ---
      function render(){
        // clear
        ctx.clearRect(0,0,W,H);
        const vw = W/dpr, vh = H/dpr;

        // subtle vignette
        const grd = ctx.createRadialGradient(vw/2, 0, 60, vw/2, 0, Math.max(vw,vh));
        grd.addColorStop(0, 'rgba(167,139,250,0.05)');
        grd.addColorStop(1, 'rgba(2,6,23,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,vw,vh);

        // glow pass
         ctx.save(); ctx.globalCompositeOperation = 'lighter';
        // pins
        for(let p of pins){
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r+1.2, 0, Math.PI*2);
           ctx.fillStyle = 'rgba(0,229,255,0.45)'; ctx.fill();
        }
        // slot lights baseline
        for(let i=0;i<slots.length;i++){
          const s = slots[i];
          const cx = s.x + s.w/2; const y = groundY-14; const intensity = multipliers[i]/Math.max(...multipliers);
          ctx.beginPath(); ctx.arc(cx, y, 10 + intensity*6, 0, Math.PI*2);
           ctx.fillStyle = `rgba(200,255,0, ${0.10 + intensity*0.20})`; ctx.fill();
        }
        ctx.restore();

         // grid bars (shorter to keep games quick and readable)
         ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2;
         for(let i=0;i<=slots.length;i++){
           const s = slots[0]; const x = (i===0)? s.x : s.x + i*s.w;
           ctx.beginPath(); ctx.moveTo(x, groundY-20); ctx.lineTo(x, groundY-80); ctx.stroke();
         }
        // ground
         ctx.fillStyle = '#0b1323'; ctx.fillRect(0, groundY-6, vw, 12);

        // balls trails
        ctx.save(); ctx.globalCompositeOperation = 'lighter';
        for(let b of balls){
          for(let i=0;i<b.trail.length;i++){
            const t = b.trail[i]; const a = (i/b.trail.length)*0.5;
            ctx.fillStyle = `hsla(${b.hue}, 100%, 60%, ${a})`;
            ctx.beginPath(); ctx.arc(t.x, t.y, Math.max(1, 6*i/b.trail.length), 0, Math.PI*2); ctx.fill();
          }
        }
        ctx.restore();

         // balls
         for(let b of balls){
           ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
           ctx.fillStyle = `hsl(${b.hue}, 100%, 60%)`; ctx.fill();
           ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.stroke();
         }
         // multiplier bar near ground
         ctx.save();
         ctx.font = '12px system-ui';
         ctx.textAlign = 'center';
         for(let i=0;i<slots.length;i++){
           const s = slots[i];
           const cx = s.x + s.w/2; const y = groundY-36;
           const m = multipliers[i];
           const intensity = m/Math.max(...multipliers);
            ctx.fillStyle = `rgba(0,229,255, ${0.12 + intensity*0.18})`;
           ctx.fillRect(s.x+2, y-14, s.w-4, 6);
            ctx.fillStyle = '#ECECEC';
            ctx.fillText('×'+m, cx, y-18);
         }
         ctx.restore();

        // confetti
        for(let p of confetti){
          ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot);
          ctx.fillStyle = `hsl(${p.hue},100%,60%)`; ctx.fillRect(-3,-1.5,6,3);
          ctx.restore();
        }
      }

      // --- Loop ---
      let last = performance.now();
      function loop(ts){
        const dt = Math.min(0.033, (ts-last)/1000); last = ts;
        step(dt); render();
        requestAnimationFrame(loop);
      }

      // --- Events ---
      new ResizeObserver(()=>resize()).observe(document.body);
      window.addEventListener('orientationchange', ()=>setTimeout(resize,150));
       cvs.addEventListener('click', ()=>{ spawnBall(1); animateHit(); });
      cvs.addEventListener('touchstart', ()=>spawnBall(1), {passive:true});
      btnDrop.addEventListener('click', ()=>spawnBall(1));
       let autoTimer = null;
       function setAuto(state){
         auto = state; btnAuto.textContent = 'Auto: ' + (auto?'Açık':'Kapalı');
         if(auto){
           if(autoTimer) clearInterval(autoTimer);
           autoTimer = setInterval(()=> spawnBall(1), 900); // second-level cadence
         }else{
           if(autoTimer) clearInterval(autoTimer); autoTimer=null;
         }
       }
       btnAuto.addEventListener('click', ()=>{ setAuto(!auto); });
       
      elRows.addEventListener('change', ()=>{ rebuildBoard(); });
      elRisk.addEventListener('change', ()=>{ rebuildBoard(); });

       // init
      resize();
      requestAnimationFrame(loop);
    </script>
  </body>
  </html>


